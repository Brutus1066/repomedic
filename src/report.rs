use crate::scanner::{Issue, ScanResult, Severity};
use serde::Serialize;
use std::env;
use std::fs;
use std::io;
use std::path::Path;

const VERSION: &str = env!("CARGO_PKG_VERSION");

/// Clean Windows extended-length path prefix for display.
pub fn clean_path(path: &Path) -> String {
    let s = path.display().to_string();
    s.strip_prefix(r"\\?\").unwrap_or(&s).to_string()
}

#[derive(Serialize)]
pub struct JsonReport<'a> {
    pub path: String,
    pub score: u8,
    pub grade: &'static str,
    pub issues: Vec<&'a Issue>,
    pub result: &'a ScanResult,
}

pub fn use_color(no_color_flag: bool) -> bool {
    !no_color_flag && env::var("NO_COLOR").is_err()
}

fn ansi(s: &str, code: &str, color: bool) -> String {
    if color {
        format!("\x1b[{}m{}\x1b[0m", code, s)
    } else {
        s.to_string()
    }
}

pub fn generate(result: &ScanResult, path: &Path) -> io::Result<String> {
    let mut r = String::new();
    r.push_str("# Repository Health Report\n\n");
    r.push_str(&format!(
        "**Path:** `{}`\n\n## Status\n\n| Check | Status |\n|-------|--------|\n",
        clean_path(path)
    ));
    let checks = [
        ("Git repository", result.has_git),
        ("README", result.has_readme),
        ("LICENSE", result.has_license),
        (".gitignore", result.has_gitignore),
        ("CHANGELOG", result.has_changelog),
        ("CONTRIBUTING", result.has_contributing),
        ("CODE_OF_CONDUCT", result.has_code_of_conduct),
        ("SECURITY", result.has_security),
        (".editorconfig", result.has_editorconfig),
        (".gitattributes", result.has_gitattributes),
        ("Tests directory", result.has_tests),
        ("Docs directory", result.has_docs),
    ];
    for (name, ok) in checks {
        r.push_str(&format!(
            "| {} | {} |\n",
            name,
            if ok { "OK" } else { "MISSING" }
        ));
    }
    r.push('\n');
    if result.is_monorepo {
        if let Some(ref wt) = result.workspace_type {
            r.push_str(&format!("## Monorepo\n\n- Type: {}\n\n", wt));
        }
    }
    if !result.linter_configs.is_empty() {
        r.push_str("## Linter Configs\n\n");
        for c in &result.linter_configs {
            r.push_str(&format!("- `{}`\n", c));
        }
        r.push('\n');
    }
    if !result.ci_systems.is_empty() {
        r.push_str("## CI/CD\n\n");
        for ci in &result.ci_systems {
            r.push_str(&format!("- {}\n", ci.name()));
        }
        r.push('\n');
    }
    if !result.languages.is_empty() {
        r.push_str("## Languages Detected\n\n");
        for l in &result.languages {
            r.push_str(&format!("- {}\n", l.name()));
        }
        r.push('\n');
    }
    if !result.build_systems.is_empty() {
        r.push_str("## Build Systems\n\n");
        for s in &result.build_systems {
            r.push_str(&format!("- {}\n", s.name()));
        }
        r.push('\n');
    }
    if !result.dependency_files.is_empty() {
        r.push_str("## Dependency Files\n\n");
        for f in &result.dependency_files {
            r.push_str(&format!("- `{}`\n", f));
        }
        r.push('\n');
    }
    let issues = collect_issues(result);
    if !issues.is_empty() {
        r.push_str("## Issues\n\n");
        for i in &issues {
            r.push_str(&format!(
                "- [{}] {}\n",
                severity_label(i.severity),
                i.message
            ));
        }
        r.push('\n');
    }
    r.push_str("---\n*Generated by [RepoMedic](https://kindware.dev)*\n");
    Ok(r)
}

pub fn write(result: &ScanResult, path: &Path) -> io::Result<()> {
    let report = generate(result, path)?;
    let output_path = path.join("REPO_REPORT.md");
    fs::write(&output_path, report)?;
    println!("Report written to: {}", clean_path(&output_path));
    Ok(())
}

fn severity_label(s: Severity) -> &'static str {
    match s {
        Severity::Error => "ERROR",
        Severity::Warning => "WARN",
        Severity::Info => "INFO",
    }
}

pub fn collect_issues(result: &ScanResult) -> Vec<Issue> {
    let mut issues = Vec::new();
    if !result.has_git {
        issues.push(Issue::error("Not a Git repository (no .git directory)"));
    }
    if !result.has_readme {
        issues.push(Issue::error("Missing README.md"));
    }
    if !result.has_license {
        issues.push(Issue::error("Missing LICENSE file"));
    }
    if !result.has_gitignore {
        issues.push(Issue::warning("Missing .gitignore"));
    }
    if !result.has_changelog {
        issues.push(Issue::warning("Missing CHANGELOG"));
    }
    if !result.has_contributing {
        issues.push(Issue::warning("Missing CONTRIBUTING.md"));
    }
    if !result.has_code_of_conduct {
        issues.push(Issue::warning("Missing CODE_OF_CONDUCT.md"));
    }
    if !result.has_security {
        issues.push(Issue::warning("Missing SECURITY.md"));
    }
    if !result.has_editorconfig {
        issues.push(Issue::warning("Missing .editorconfig"));
    }
    if result.ci_systems.is_empty() {
        issues.push(Issue::warning("No CI/CD configuration detected"));
    }
    if result.languages.is_empty() {
        issues.push(Issue::info("No source code detected"));
    }
    if result.build_systems.is_empty() && !result.languages.is_empty() {
        issues.push(Issue::info("No build system detected"));
    }
    if !result.has_tests && !result.languages.is_empty() {
        issues.push(Issue::info("No test directory detected"));
    }
    // Check for missing lock files when manifest exists
    let lock_checks: &[(&str, &[&str], &str)] = &[
        (
            "package.json",
            &["package-lock.json", "yarn.lock", "pnpm-lock.yaml"],
            "npm/yarn/pnpm lock file",
        ),
        ("Pipfile", &["Pipfile.lock"], "Pipfile.lock"),
        ("Gemfile", &["Gemfile.lock"], "Gemfile.lock"),
        ("composer.json", &["composer.lock"], "composer.lock"),
        ("go.mod", &["go.sum"], "go.sum"),
        ("mix.exs", &["mix.lock"], "mix.lock"),
    ];
    for (manifest, locks, desc) in lock_checks {
        if result.dependency_files.iter().any(|f| f == *manifest) {
            let has_lock = locks
                .iter()
                .any(|l| result.dependency_files.iter().any(|f| f == *l));
            if !has_lock {
                issues.push(Issue::warning(format!(
                    "Missing {}: found {} but no lock file (reproducible builds)",
                    desc, manifest
                )));
            }
        }
    }
    // Cargo.lock check: only warn for binaries, not libraries
    if result.dependency_files.iter().any(|f| f == "Cargo.toml") {
        let has_lock = result.dependency_files.iter().any(|f| f == "Cargo.lock");
        if !has_lock {
            // Info-level since libraries often don't commit Cargo.lock
            issues.push(Issue::info(
                "No Cargo.lock found (consider committing for binary/app projects)",
            ));
        }
    }
    for f in &result.large_files {
        issues.push(Issue::warning(format!("Large file detected (>5MB): {}", f)));
    }
    for s in &result.potential_secrets {
        issues.push(Issue::error(format!(
            "Potential {} in {} at line {}",
            s.pattern, s.file, s.line
        )));
    }
    issues
}

pub fn has_errors(result: &ScanResult) -> bool {
    collect_issues(result)
        .iter()
        .any(|i| i.severity == Severity::Error)
}

pub fn has_warnings(result: &ScanResult) -> bool {
    collect_issues(result)
        .iter()
        .any(|i| i.severity == Severity::Warning)
}

pub fn to_json(result: &ScanResult, path: &Path) -> String {
    let issues = collect_issues(result);
    let score = calculate_score(result);
    let report = JsonReport {
        path: clean_path(path),
        score,
        grade: score_grade(score),
        issues: issues.iter().collect(),
        result,
    };
    serde_json::to_string_pretty(&report).unwrap_or_else(|_| "{}".to_string())
}

pub fn to_sarif(result: &ScanResult, path: &Path) -> String {
    let issues = collect_issues(result);
    let rule_map = [
        ("missing-readme", "Missing README.md", "error"),
        ("missing-license", "Missing LICENSE file", "error"),
        ("not-git-repo", "Not a Git repository", "error"),
        ("missing-gitignore", "Missing .gitignore", "warning"),
        ("missing-changelog", "Missing CHANGELOG", "warning"),
        ("missing-contributing", "Missing CONTRIBUTING.md", "warning"),
        (
            "missing-code-of-conduct",
            "Missing CODE_OF_CONDUCT.md",
            "warning",
        ),
        ("missing-security", "Missing SECURITY.md", "warning"),
        ("missing-editorconfig", "Missing .editorconfig", "warning"),
        ("no-ci", "No CI/CD configuration detected", "warning"),
        ("no-tests", "No test directory detected", "warning"),
        (
            "missing-lock-file",
            "Missing lock file for reproducible builds",
            "warning",
        ),
        ("large-file", "Large file detected (>5MB)", "warning"),
        ("potential-secret", "Potential secret detected", "error"),
    ];
    let rules: Vec<_> = rule_map.iter().map(|(id, desc, level)| serde_json::json!({
        "id": id, "shortDescription": { "text": desc }, "defaultConfiguration": { "level": level }
    })).collect();
    let results: Vec<_> = issues.iter().filter_map(|issue| {
        let m = issue.message.as_str();
        let rule_id = if m.contains("README") { "missing-readme" }
            else if m.contains("LICENSE") { "missing-license" } else if m.contains("Git repository") { "not-git-repo" }
            else if m.contains(".gitignore") { "missing-gitignore" } else if m.contains("CHANGELOG") { "missing-changelog" }
            else if m.contains("CONTRIBUTING") { "missing-contributing" } else if m.contains("CODE_OF_CONDUCT") { "missing-code-of-conduct" }
            else if m.contains("SECURITY") { "missing-security" } else if m.contains(".editorconfig") { "missing-editorconfig" }
            else if m.contains("CI/CD") { "no-ci" } else if m.contains("test") { "no-tests" }
            else if m.contains("lock file") || m.contains("Cargo.lock") { "missing-lock-file" }
            else if m.contains("Large file") { "large-file" } else if m.contains("secret") { "potential-secret" } else { return None };
        let level = match issue.severity { Severity::Error => "error", Severity::Warning => "warning", Severity::Info => "note" };
        Some(serde_json::json!({ "ruleId": rule_id, "level": level, "message": { "text": &issue.message },
            "locations": [{ "physicalLocation": { "artifactLocation": { "uri": clean_path(path) } } }] }))
    }).collect();
    serde_json::to_string_pretty(&serde_json::json!({
        "$schema": "https://json.schemastore.org/sarif-2.1.0.json", "version": "2.1.0",
        "runs": [{ "tool": { "driver": { "name": "RepoMedic", "version": VERSION, "informationUri": "https://kindware.dev", "rules": rules } }, "results": results }]
    })).unwrap_or_else(|_| "{}".to_string())
}

pub fn print_summary(result: &ScanResult, quiet: bool, verbose: bool, color: bool) {
    if quiet {
        return;
    }
    println!("Repository scan complete.\n");
    if verbose {
        println!(
            "Stats: {} files scanned, {} dirs traversed, {}ms\n",
            result.scan_stats.files_scanned,
            result.scan_stats.dirs_traversed,
            result.scan_stats.scan_duration_ms
        );
    }
    println!("Status:");
    let (yes, no) = (ansi("yes", "32", color), ansi("no", "31", color));
    let checks = [
        ("Git repository", result.has_git),
        ("README", result.has_readme),
        ("LICENSE", result.has_license),
        (".gitignore", result.has_gitignore),
        ("CHANGELOG", result.has_changelog),
        ("CONTRIBUTING", result.has_contributing),
        ("CODE_OF_CONDUCT", result.has_code_of_conduct),
        ("SECURITY", result.has_security),
        (".editorconfig", result.has_editorconfig),
        (".gitattributes", result.has_gitattributes),
        ("Tests", result.has_tests),
        ("Docs", result.has_docs),
    ];
    for (name, ok) in checks {
        println!(
            "  {:16} {}",
            format!("{}:", name),
            if ok { &yes } else { &no }
        );
    }
    if result.is_monorepo {
        if let Some(ref wt) = result.workspace_type {
            println!("\nMonorepo: {}", wt);
        }
    }
    if !result.linter_configs.is_empty() {
        println!("\nLinter configs: {}", result.linter_configs.join(", "));
    }
    if !result.ci_systems.is_empty() {
        println!(
            "\nCI/CD: {}",
            result
                .ci_systems
                .iter()
                .map(|c| c.name())
                .collect::<Vec<_>>()
                .join(", ")
        );
    }
    if !result.languages.is_empty() {
        println!(
            "Languages: {}",
            result
                .languages
                .iter()
                .map(|l| l.name())
                .collect::<Vec<_>>()
                .join(", ")
        );
    }
    if !result.build_systems.is_empty() {
        println!(
            "Build systems: {}",
            result
                .build_systems
                .iter()
                .map(|b| b.name())
                .collect::<Vec<_>>()
                .join(", ")
        );
    }
    let issues = collect_issues(result);
    if !issues.is_empty() {
        let (e, w, i) = (
            issues
                .iter()
                .filter(|x| x.severity == Severity::Error)
                .count(),
            issues
                .iter()
                .filter(|x| x.severity == Severity::Warning)
                .count(),
            issues
                .iter()
                .filter(|x| x.severity == Severity::Info)
                .count(),
        );
        println!("\nIssues: {} error(s), {} warning(s), {} info", e, w, i);
        for issue in &issues {
            let prefix = match issue.severity {
                Severity::Error => ansi("!", "31", color),
                Severity::Warning => ansi("?", "33", color),
                Severity::Info => ansi("-", "34", color),
            };
            println!("  {} {}", prefix, issue.message);
        }
    } else {
        println!("\nNo issues found.");
    }
}

/// Calculate repository health score (0-100).
pub fn calculate_score(result: &ScanResult) -> u8 {
    let mut score: i32 = 100;
    let issues = collect_issues(result);
    for issue in &issues {
        match issue.severity {
            Severity::Error => score -= 15,
            Severity::Warning => score -= 5,
            Severity::Info => score -= 1,
        }
    }
    // Bonus points for good practices
    if result.has_tests {
        score += 5;
    }
    if result.has_docs {
        score += 3;
    }
    if !result.ci_systems.is_empty() {
        score += 5;
    }
    score.clamp(0, 100) as u8
}

/// Get letter grade from score.
pub fn score_grade(score: u8) -> &'static str {
    match score {
        90..=100 => "A",
        80..=89 => "B",
        70..=79 => "C",
        60..=69 => "D",
        _ => "F",
    }
}

/// Get ANSI color code for score.
fn score_color(score: u8) -> &'static str {
    match score {
        90..=100 => "32", // green
        70..=89 => "33",  // yellow
        _ => "31",        // red
    }
}

/// Generate shields.io badge markdown.
pub fn generate_badge(score: u8) -> String {
    let grade = score_grade(score);
    let color = match score {
        90..=100 => "brightgreen",
        80..=89 => "green",
        70..=79 => "yellow",
        60..=69 => "orange",
        _ => "red",
    };
    format!(
        "![RepoMedic Score](https://img.shields.io/badge/RepoMedic-{}%20({}%25)-{})",
        grade, score, color
    )
}

/// Print score summary.
pub fn print_score(result: &ScanResult, color: bool) {
    let score = calculate_score(result);
    let grade = score_grade(score);
    let colored_score = if color {
        format!("\x1b[{}m{}\x1b[0m", score_color(score), score)
    } else {
        score.to_string()
    };
    println!(
        "Repository Health Score: {}/100 (Grade: {})",
        colored_score, grade
    );
    println!("\nBadge for README:");
    println!("  {}", generate_badge(score));
}

/// Get fix command for an issue.
fn get_fix_command(msg: &str) -> Option<&'static str> {
    if msg.contains("README") {
        Some("repomedic generate --readme")
    } else if msg.contains("LICENSE") {
        Some("repomedic generate --license --author \"Your Name\"")
    } else if msg.contains(".gitignore") {
        Some("repomedic generate --gitignore")
    } else if msg.contains("CHANGELOG") {
        Some("repomedic generate --changelog")
    } else if msg.contains("CONTRIBUTING") {
        Some("repomedic generate --contributing")
    } else if msg.contains("CODE_OF_CONDUCT") {
        Some("repomedic generate --codeofconduct")
    } else if msg.contains("SECURITY") {
        Some("repomedic generate --security")
    } else if msg.contains(".editorconfig") {
        Some("repomedic generate --editorconfig")
    } else if msg.contains("Git repository") {
        Some("git init")
    } else {
        None
    }
}

/// Print actionable fix suggestions.
pub fn print_suggestions(result: &ScanResult, color: bool) {
    let issues = collect_issues(result);
    let fixable: Vec<_> = issues
        .iter()
        .filter_map(|i| get_fix_command(&i.message).map(|cmd| (i, cmd)))
        .collect();

    if fixable.is_empty() {
        println!("No actionable suggestions. Repository looks good!");
        return;
    }

    println!("Fix suggestions:\n");
    for (issue, cmd) in &fixable {
        let prefix = match issue.severity {
            Severity::Error => {
                if color {
                    "\x1b[31m!".to_string()
                } else {
                    "!".to_string()
                }
            }
            Severity::Warning => {
                if color {
                    "\x1b[33m?".to_string()
                } else {
                    "?".to_string()
                }
            }
            Severity::Info => {
                if color {
                    "\x1b[34m-".to_string()
                } else {
                    "-".to_string()
                }
            }
        };
        let reset = if color { "\x1b[0m" } else { "" };
        println!("  {}{} {}", prefix, reset, issue.message);
        println!("    Fix: {}\n", cmd);
    }
}

/// Print one-line doctor summary (for shell prompts and quick checks).
pub fn print_doctor(result: &ScanResult, color: bool) {
    let score = calculate_score(result);
    let grade = score_grade(score);
    let issues = collect_issues(result);
    let errors = issues
        .iter()
        .filter(|i| i.severity == Severity::Error)
        .count();
    let warnings = issues
        .iter()
        .filter(|i| i.severity == Severity::Warning)
        .count();

    let status = if errors > 0 {
        if color {
            "\x1b[31m✗\x1b[0m"
        } else {
            "✗"
        }
    } else if warnings > 0 {
        if color {
            "\x1b[33m!\x1b[0m"
        } else {
            "!"
        }
    } else if color {
        "\x1b[32m✓\x1b[0m"
    } else {
        "✓"
    };

    let grade_colored = if color {
        format!("\x1b[{}m{}\x1b[0m", score_color(score), grade)
    } else {
        grade.to_string()
    };

    println!(
        "{} RepoMedic: {} ({}/100) | {} error(s), {} warning(s)",
        status, grade_colored, score, errors, warnings
    );
}

/// Generate plain text report.
pub fn to_text(result: &ScanResult, path: &Path) -> String {
    let score = calculate_score(result);
    let grade = score_grade(score);
    let issues = collect_issues(result);
    let mut out = String::new();

    out.push_str("RepoMedic Scan Report\n");
    out.push_str("=====================\n\n");
    out.push_str(&format!("Path:  {}\n", clean_path(path)));
    out.push_str(&format!("Score: {}/100 (Grade {})\n\n", score, grade));

    out.push_str("Status:\n");
    let checks = [
        ("Git repository", result.has_git),
        ("README", result.has_readme),
        ("LICENSE", result.has_license),
        (".gitignore", result.has_gitignore),
        ("CHANGELOG", result.has_changelog),
        ("CONTRIBUTING", result.has_contributing),
        ("CODE_OF_CONDUCT", result.has_code_of_conduct),
        ("SECURITY", result.has_security),
        (".editorconfig", result.has_editorconfig),
        ("Tests", result.has_tests),
        ("Docs", result.has_docs),
    ];
    for (name, ok) in checks {
        out.push_str(&format!(
            "  {:16} {}\n",
            format!("{}:", name),
            if ok { "YES" } else { "NO" }
        ));
    }

    if !issues.is_empty() {
        out.push_str("\nIssues:\n");
        for issue in &issues {
            let prefix = match issue.severity {
                Severity::Error => "[ERROR]",
                Severity::Warning => "[WARN] ",
                Severity::Info => "[INFO] ",
            };
            out.push_str(&format!("  {} {}\n", prefix, issue.message));
        }
    }

    out.push_str("\n---\nGenerated by RepoMedic (https://github.com/Brutus1066/repomedic)\n");
    out
}

/// Generate CSV report.
pub fn to_csv(result: &ScanResult, path: &Path) -> String {
    let score = calculate_score(result);
    let grade = score_grade(score);
    let issues = collect_issues(result);
    let mut out = String::new();

    out.push_str("type,item,status,message\n");
    out.push_str(&format!("score,health,{},{}\n", score, grade));

    let checks = [
        ("check", "git_repository", result.has_git),
        ("check", "readme", result.has_readme),
        ("check", "license", result.has_license),
        ("check", "gitignore", result.has_gitignore),
        ("check", "changelog", result.has_changelog),
        ("check", "contributing", result.has_contributing),
        ("check", "code_of_conduct", result.has_code_of_conduct),
        ("check", "security", result.has_security),
        ("check", "editorconfig", result.has_editorconfig),
        ("check", "tests", result.has_tests),
        ("check", "docs", result.has_docs),
    ];
    for (typ, name, ok) in checks {
        out.push_str(&format!(
            "{},{},{},\n",
            typ,
            name,
            if ok { "pass" } else { "fail" }
        ));
    }

    for issue in &issues {
        let sev = match issue.severity {
            Severity::Error => "error",
            Severity::Warning => "warning",
            Severity::Info => "info",
        };
        // Escape quotes in message for CSV
        let msg = issue.message.replace('"', "\"\"");
        out.push_str(&format!(
            "issue,{},\"{}\",\"{}\"\n",
            sev,
            clean_path(path),
            msg
        ));
    }

    out
}

/// Export report to file based on extension.
pub fn export_to_file(result: &ScanResult, path: &Path, output_file: &Path) -> io::Result<()> {
    let ext = output_file
        .extension()
        .and_then(|e| e.to_str())
        .unwrap_or("txt")
        .to_lowercase();

    let content = match ext.as_str() {
        "json" => to_json(result, path),
        "md" | "markdown" => generate(result, path)?,
        "csv" => to_csv(result, path),
        _ => to_text(result, path), // .txt and others
    };

    fs::write(output_file, content)?;
    println!("Exported to: {}", clean_path(output_file));
    Ok(())
}
